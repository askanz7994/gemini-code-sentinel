
import { useState } from "react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { Vulnerability, RepoInfo, ScanState } from "@/types/vulnerability";

export const useVulnerabilityScanner = () => {
  const [state, setState] = useState<ScanState>({
    repoUrl: "",
    githubToken: "",
    isLoading: false,
    activeAction: null,
    results: null,
    repoFiles: null,
    repoInfo: null,
    fileContents: {},
    loadingFileContentForVulnId: null,
    isScanning: false,
  });

  const { toast } = useToast();

  const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  const handleFetchFiles = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!state.repoUrl) {
      toast({ title: "Error", description: "Please enter a GitHub repository URL.", variant: "destructive" });
      return;
    }
    
    if (!state.githubToken) {
      toast({ title: "Error", description: "GitHub Personal Access Token is required.", variant: "destructive" });
      return;
    }
    
    setState(prev => ({
      ...prev,
      isLoading: true,
      activeAction: 'fetch',
      results: null,
      repoFiles: null,
      repoInfo: null,
    }));
    
    try {
      const githubRepoUrlPattern = /^(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9-._]+)\/([a-zA-Z0-9-._]+)(?:\.git)?\/?$/;
      const match = state.repoUrl.match(githubRepoUrlPattern);

      if (!match) {
        toast({ title: "Error", description: "Invalid GitHub repository URL format. Please use 'https://github.com/owner/repo'.", variant: "destructive" });
        setState(prev => ({ ...prev, isLoading: false, activeAction: null }));
        return;
      }

      let [, owner, repo] = match;
      if (repo.endsWith('.git')) {
        repo = repo.slice(0, -4);
      }
      const repoInfo = { owner, repo };

      const headers: HeadersInit = {
        'Authorization': `Bearer ${state.githubToken}`
      };

      toast({ title: "Fetching Files...", description: "Getting repository file list." });
      
      const repoInfoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
      if (!repoInfoResponse.ok) {
        if (repoInfoResponse.status === 404) {
          throw new Error("Repository not found. Check the URL and ensure your token has access to this repository.");
        }
        if (repoInfoResponse.status === 401) {
          throw new Error("Authentication failed. Make sure your GitHub Personal Access Token is correct and has 'repo' scope.");
        }
        if (repoInfoResponse.status === 403) {
          const errorData = await repoInfoResponse.json().catch(() => ({ message: "Rate limit likely exceeded or insufficient permissions."}));
          console.error("GitHub API Error:", errorData);
          throw new Error(`GitHub API access forbidden. ${errorData.message}`);
        }
        throw new Error(`Failed to fetch repository info: ${repoInfoResponse.statusText} (Status: ${repoInfoResponse.status})`);
      }
      const repoData = await repoInfoResponse.json();
      const defaultBranch = repoData.default_branch;

      const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${defaultBranch}?recursive=1`, { headers });
      if (!treeResponse.ok) {
        if (treeResponse.status === 404) {
          throw new Error("Could not find the repository's file tree. The default branch may not exist or is empty.");
        }
        if (treeResponse.status === 401) {
          throw new Error("Authentication failed. Make sure your GitHub Personal Access Token is correct and has 'repo' scope.");
        }
        if (treeResponse.status === 403) {
          const errorData = await treeResponse.json().catch(() => ({ message: "Rate limit likely exceeded or insufficient permissions."}));
          console.error("GitHub API Error:", errorData);
          throw new Error(`GitHub API access forbidden while fetching file tree. ${errorData.message}`);
        }
        throw new Error(`Failed to fetch repository file tree: ${treeResponse.statusText} (Status: ${treeResponse.status})`);
      }
      const treeData = await treeResponse.json();
      if(treeData.truncated) {
        toast({ title: "Warning", description: "Repository is too large, some files may not be scanned.", variant: "default" });
      }

      const scannableExtensions = ['.js', '.jsx', '.ts', '.tsx', 'package.json', 'Dockerfile', '.yml', '.yaml', '.py', '.go', '.java', '.rb', '.hcl'];
      const scannableFiles = ['requirements.txt', 'pom.xml', 'build.gradle'];
      const ignoredPaths = ['node_modules/', 'dist/', 'build/', '.git/', 'vendor/'];

      const filesToScan = treeData.tree.filter((file: any) => 
        file.type === 'blob' &&
        !ignoredPaths.some(ignoredPath => file.path.startsWith(ignoredPath)) &&
        (scannableExtensions.some(ext => file.path.endsWith(ext)) || scannableFiles.includes(file.path.split('/').pop()))
      );
      
      setState(prev => ({ ...prev, repoFiles: filesToScan, repoInfo }));

      if (filesToScan.length > 0) {
        toast({ title: "Files Loaded", description: `Found ${filesToScan.length} scannable files. Ready to scan.` });
      } else {
        toast({ title: "No Files Found", description: "No scannable files were found in this repository." });
      }

    } catch (error) {
      console.error("Fetch failed:", error);
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      setState(prev => ({ ...prev, repoFiles: null }));
    } finally {
      setState(prev => ({ ...prev, isLoading: false, activeAction: null }));
    }
  };

  const handleStartScan = async () => {
    if (!state.repoFiles || state.repoFiles.length === 0) {
      toast({ title: "Error", description: "No files to scan.", variant: "destructive" });
      return;
    }
    if (!state.repoInfo) {
      toast({ title: "Error", description: "Repository information is missing. Please fetch files first.", variant: "destructive" });
      return;
    }

    setState(prev => ({
      ...prev,
      isLoading: true,
      activeAction: 'scan',
      isScanning: true,
      results: null,
    }));
    
    try {
      const { owner, repo } = state.repoInfo;

      const headers: HeadersInit = {};
      if (state.githubToken) {
        headers['Authorization'] = `Bearer ${state.githubToken}`;
      }

      let vulnerabilityIdCounter = 1;
      let allVulnerabilities: Vulnerability[] = [];

      for (const [index, file] of state.repoFiles.entries()) {
        toast({ title: "Scanning", description: `Analyzing ${file.path} (${index + 1}/${state.repoFiles.length})` });
        
        await sleep(200);

        const fileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${file.path}`;
        const githubFileResponse = await fetch(fileUrl, { headers });

        if (!githubFileResponse.ok) {
          if (githubFileResponse.status === 401) {
            throw new Error("Authentication failed while fetching a file. Make sure your GitHub token is correct and has 'repo' scope. Scan aborted.");
          }
          console.warn(`Could not fetch file: ${file.path}. Status: ${githubFileResponse.statusText}`);
          continue;
        }

        try {
          const fileData = await githubFileResponse.json();
          
          if (fileData.size > 100000) { 
            console.warn(`Skipping large file: ${file.path}`);
            continue;
          }

          if (!fileData.content) {
            console.warn(`Skipping empty file: ${file.path}`);
            continue;
          }

          const fileContent = atob(fileData.content);

          const { data, error } = await supabase.functions.invoke('scan-vulnerability', {
            body: {
              fileContent: fileContent,
              filePath: file.path
            }
          });

          if (error) {
            console.error(`Error scanning file ${file.path}:`, error);
            toast({ title: "Scan Error", description: `Could not scan ${file.path}: ${error.message}`, variant: "destructive" });
            continue;
          }

          const vulnerabilitiesInFile = data.vulnerabilities || [];

          if (vulnerabilitiesInFile.length > 0) {
            const newVulnerabilities = vulnerabilitiesInFile.map((v: any) => ({
              ...v,
              id: vulnerabilityIdCounter++,
              file: file.path
            }));
            allVulnerabilities = [...allVulnerabilities, ...newVulnerabilities];
          }
        } catch (fileError) {
          console.error(`Error processing file ${file.path}:`, fileError);
          toast({ title: "File Processing Error", description: `An error occurred while scanning ${file.path}.`, variant: "destructive" });
        }
      }

      setState(prev => ({ ...prev, results: allVulnerabilities }));

      if (allVulnerabilities.length > 0) {
        toast({ title: "Scan Complete", description: `Found ${allVulnerabilities.length} potential vulnerabilities across ${state.repoFiles.length} files.` });
      } else {
        toast({ title: "Scan Complete", description: `Scanned ${state.repoFiles.length} files. No vulnerabilities found.` });
      }
    } catch (error) {
      console.error("Scan failed:", error);
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
    } finally {
      setState(prev => ({
        ...prev,
        isLoading: false,
        activeAction: null,
        isScanning: false,
      }));
    }
  };

  const handleViewCode = async (vulnerability: Vulnerability) => {
    if (state.fileContents[vulnerability.file] || state.loadingFileContentForVulnId === vulnerability.id) {
      return;
    }
    if (!state.repoInfo) {
      toast({ title: "Error", description: "Repository information is missing.", variant: "destructive" });
      return;
    }

    setState(prev => ({ ...prev, loadingFileContentForVulnId: vulnerability.id }));
    try {
      const { owner, repo } = state.repoInfo;
      const headers: HeadersInit = {};
      if (state.githubToken) {
        headers['Authorization'] = `Bearer ${state.githubToken}`;
      }
      
      const fileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${vulnerability.file}`;
      const response = await fetch(fileUrl, { headers });

      if (!response.ok) {
        throw new Error(`Failed to fetch file content for ${vulnerability.file}. Status: ${response.status}`);
      }

      const fileData = await response.json();
      if (!fileData.content) {
        setState(prev => ({ 
          ...prev, 
          fileContents: { ...prev.fileContents, [vulnerability.file]: "// File content is not available or file is empty." }
        }));
      } else {
        const content = atob(fileData.content);
        setState(prev => ({ 
          ...prev, 
          fileContents: { ...prev.fileContents, [vulnerability.file]: content }
        }));
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      setState(prev => ({ 
        ...prev, 
        fileContents: { ...prev.fileContents, [vulnerability.file]: `// Error: ${errorMessage}` }
      }));
    } finally {
      setState(prev => ({ ...prev, loadingFileContentForVulnId: null }));
    }
  };

  const setRepoUrl = (url: string) => {
    setState(prev => ({ ...prev, repoUrl: url }));
  };

  const setGithubToken = (token: string) => {
    setState(prev => ({ ...prev, githubToken: token }));
  };

  return {
    state,
    handleFetchFiles,
    handleStartScan,
    handleViewCode,
    setRepoUrl,
    setGithubToken,
  };
};
