import { useState } from "react";
import { useToast } from "@/hooks/use-toast";
import { useUserScans } from "@/hooks/useUserScans";
import { supabase } from "@/integrations/supabase/client";
import { Vulnerability, RepoInfo, ScanState } from "@/types/vulnerability";

export const useVulnerabilityScanner = () => {
  const { toast } = useToast();
  const { useScan, remainingScans } = useUserScans();

  const [state, setState] = useState<ScanState>({
    repoUrl: "",
    githubToken: "",
    isLoading: false,
    activeAction: null,
    results: null,
    repoFiles: null,
    repoInfo: null,
    fileContents: {},
    loadingFileContentForVulnId: null,
    isScanning: false,
  });

  const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  };

  const handleFetchFiles = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!state.repoUrl) {
      toast({ title: "Error", description: "Please enter a GitHub repository URL.", variant: "destructive" });
      return;
    }
    
    if (!state.githubToken) {
      toast({ title: "Error", description: "GitHub Personal Access Token is required.", variant: "destructive" });
      return;
    }
    
    setState(prev => ({
      ...prev,
      isLoading: true,
      activeAction: 'fetch',
      results: null,
      repoFiles: null,
      repoInfo: null,
    }));
    
    try {
      const githubRepoUrlPattern = /^(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9-._]+)\/([a-zA-Z0-9-._]+)(?:\.git)?\/?$/;
      const match = state.repoUrl.match(githubRepoUrlPattern);

      if (!match) {
        toast({ title: "Error", description: "Invalid GitHub repository URL format. Please use 'https://github.com/owner/repo'.", variant: "destructive" });
        setState(prev => ({ ...prev, isLoading: false, activeAction: null }));
        return;
      }

      let [, owner, repo] = match;
      if (repo.endsWith('.git')) {
        repo = repo.slice(0, -4);
      }
      const repoInfo = { owner, repo };

      const headers: HeadersInit = {
        'Authorization': `Bearer ${state.githubToken}`
      };

      toast({ title: "Fetching Files...", description: "Getting repository file list." });
      
      const repoInfoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
      if (!repoInfoResponse.ok) {
        if (repoInfoResponse.status === 404) {
          throw new Error("Repository not found. Check the URL and ensure your token has access to this repository.");
        }
        if (repoInfoResponse.status === 401) {
          throw new Error("Authentication failed. Make sure your GitHub Personal Access Token is correct and has 'repo' scope.");
        }
        if (repoInfoResponse.status === 403) {
          const errorData = await repoInfoResponse.json().catch(() => ({ message: "Rate limit likely exceeded or insufficient permissions."}));
          console.error("GitHub API Error:", errorData);
          throw new Error(`GitHub API access forbidden. ${errorData.message}`);
        }
        throw new Error(`Failed to fetch repository info: ${repoInfoResponse.statusText} (Status: ${repoInfoResponse.status})`);
      }
      const repoData = await repoInfoResponse.json();
      const defaultBranch = repoData.default_branch;

      const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${defaultBranch}?recursive=1`, { headers });
      if (!treeResponse.ok) {
        if (treeResponse.status === 404) {
          throw new Error("Could not find the repository's file tree. The default branch may not exist or is empty.");
        }
        if (treeResponse.status === 401) {
          throw new Error("Authentication failed. Make sure your GitHub Personal Access Token is correct and has 'repo' scope.");
        }
        if (treeResponse.status === 403) {
          const errorData = await treeResponse.json().catch(() => ({ message: "Rate limit likely exceeded or insufficient permissions."}));
          console.error("GitHub API Error:", errorData);
          throw new Error(`GitHub API access forbidden while fetching file tree. ${errorData.message}`);
        }
        throw new Error(`Failed to fetch repository file tree: ${treeResponse.statusText} (Status: ${treeResponse.status})`);
      }
      const treeData = await treeResponse.json();
      if(treeData.truncated) {
        toast({ title: "Warning", description: "Repository is too large, some files may not be scanned.", variant: "default" });
      }

      // Only exclude files in ignored paths - include all other files regardless of extension
      const ignoredPaths = ['node_modules/', 'dist/', 'build/', '.git/', 'vendor/', '.cache/', 'tmp/', 'temp/', '__pycache__/', '.pytest_cache/', '.vscode/', '.idea/', 'coverage/', 'test-results/', '.next/', '.nuxt/', '.expo/', '.history/', '.venv/', '.env/', '.mypy_cache/', '.terraform/', '.serverless/', '*.zip', '*.tar.gz', '*.rar', '*.7z', '*.png', '*.jpg', '*.jpeg', '*.gif', '*.svg', '*.ico', '*.pdf', '*.mp4'];


      const filesToScan = treeData.tree.filter((file: any) => 
        file.type === 'blob' &&
        !ignoredPaths.some(ignoredPath => file.path.startsWith(ignoredPath))
      ).map((file: any) => ({
        ...file,
        formattedSize: formatFileSize(file.size || 0)
      }));

      const totalSize = filesToScan.reduce((sum: number, file: any) => sum + (file.size || 0), 0);
      const totalFormattedSize = formatFileSize(totalSize);
      
      setState(prev => ({ ...prev, repoFiles: filesToScan, repoInfo }));

      if (filesToScan.length > 0) {
        toast({ title: "Files Loaded", description: `Found ${filesToScan.length} scannable files (${totalFormattedSize} total). Ready to scan.` });
      } else {
        toast({ title: "No Files Found", description: "No scannable files were found in this repository." });
      }

    } catch (error) {
      console.error("Fetch failed:", error);
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      setState(prev => ({ ...prev, repoFiles: null }));
    } finally {
      setState(prev => ({ ...prev, isLoading: false, activeAction: null }));
    }
  };

  const handleStartScan = async (files: string[]) => {
    // Check if user has remaining scans
    if (remainingScans <= 0) {
      toast({
        title: "No scans available",
        description: "You don't have any remaining scans. Please purchase more to continue.",
        variant: "destructive",
      });
      return;
    }

    // Use a scan credit before starting
    const scanUsed = await useScan();
    if (!scanUsed) {
      return; // Error already handled in useScan
    }

    setState(prev => ({ 
      ...prev, 
      isScanning: true, 
      activeAction: "scanning" 
    }));

    try {
      const { data, error } = await supabase.functions.invoke('scan-vulnerability', {
        body: { 
          repoUrl: state.repoUrl, 
          files,
          githubToken: state.githubToken 
        }
      });

      if (error) {
        console.error('Scanning error:', error);
        toast({
          title: "Scan failed",
          description: "There was an error scanning the repository. Please try again.",
          variant: "destructive",
        });
      } else {
        setState(prev => ({ 
          ...prev, 
          results: data.vulnerabilities || []
        }));
        
        if (data.vulnerabilities && data.vulnerabilities.length > 0) {
          toast({
            title: "Scan completed",
            description: `Found ${data.vulnerabilities.length} potential vulnerabilities.`,
          });
        } else {
          toast({
            title: "Scan completed",
            description: "No vulnerabilities found. Your code looks secure!",
          });
        }
      }
    } catch (error) {
      console.error('Unexpected error:', error);
      toast({
        title: "Unexpected error",
        description: "Something went wrong. Please try again.",
        variant: "destructive",
      });
    } finally {
      setState(prev => ({ 
        ...prev, 
        isScanning: false, 
        activeAction: null 
      }));
    }
  };

  const handleViewCode = async (vulnerability: Vulnerability) => {
    if (state.fileContents[vulnerability.file] || state.loadingFileContentForVulnId === vulnerability.id) {
      return;
    }
    if (!state.repoInfo) {
      toast({ title: "Error", description: "Repository information is missing.", variant: "destructive" });
      return;
    }

    setState(prev => ({ ...prev, loadingFileContentForVulnId: vulnerability.id }));
    try {
      const { owner, repo } = state.repoInfo;
      const headers: HeadersInit = {};
      if (state.githubToken) {
        headers['Authorization'] = `Bearer ${state.githubToken}`;
      }
      
      const fileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${vulnerability.file}`;
      const response = await fetch(fileUrl, { headers });

      if (!response.ok) {
        throw new Error(`Failed to fetch file content for ${vulnerability.file}. Status: ${response.status}`);
      }

      const fileData = await response.json();
      if (!fileData.content) {
        setState(prev => ({ 
          ...prev, 
          fileContents: { ...prev.fileContents, [vulnerability.file]: "// File content is not available or file is empty." }
        }));
      } else {
        const content = atob(fileData.content);
        setState(prev => ({ 
          ...prev, 
          fileContents: { ...prev.fileContents, [vulnerability.file]: content }
        }));
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      setState(prev => ({ 
        ...prev, 
        fileContents: { ...prev.fileContents, [vulnerability.file]: `// Error: ${errorMessage}` }
      }));
    } finally {
      setState(prev => ({ ...prev, loadingFileContentForVulnId: null }));
    }
  };

  const setRepoUrl = (url: string) => {
    setState(prev => ({ ...prev, repoUrl: url }));
  };

  const setGithubToken = (token: string) => {
    setState(prev => ({ ...prev, githubToken: token }));
  };

  return {
    state,
    handleFetchFiles,
    handleStartScan,
    handleViewCode,
    setRepoUrl,
    setGithubToken,
  };
};
