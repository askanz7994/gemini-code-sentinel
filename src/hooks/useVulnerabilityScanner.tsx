
import { useState } from "react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { Vulnerability, RepoInfo, ScanState } from "@/types/vulnerability";
import { useCredits } from "@/hooks/useCredits";
import { useAuth } from "@/contexts/AuthContext";

export const useVulnerabilityScanner = () => {
  const [state, setState] = useState<ScanState>({
    repoUrl: "",
    githubToken: "",
    isLoading: false,
    activeAction: null,
    results: null,
    repoFiles: null,
    repoInfo: null,
    fileContents: {},
    loadingFileContentForVulnId: null,
    isScanning: false,
  });

  const { toast } = useToast();
  const { credits, deductCredits } = useCredits();
  const { user } = useAuth();

  const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  };

  const handleFetchFiles = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!state.repoUrl) {
      toast({ title: "Error", description: "Please enter a GitHub repository URL.", variant: "destructive" });
      return;
    }
    
    if (!state.githubToken) {
      toast({ title: "Error", description: "GitHub Personal Access Token is required.", variant: "destructive" });
      return;
    }
    
    setState(prev => ({
      ...prev,
      isLoading: true,
      activeAction: 'fetch',
      results: null,
      repoFiles: null,
      repoInfo: null,
    }));
    
    try {
      const githubRepoUrlPattern = /^(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9-._]+)\/([a-zA-Z0-9-._]+)(?:\.git)?\/?$/;
      const match = state.repoUrl.match(githubRepoUrlPattern);

      if (!match) {
        toast({ title: "Error", description: "Invalid GitHub repository URL format. Please use 'https://github.com/owner/repo'.", variant: "destructive" });
        setState(prev => ({ ...prev, isLoading: false, activeAction: null }));
        return;
      }

      let [, owner, repo] = match;
      if (repo.endsWith('.git')) {
        repo = repo.slice(0, -4);
      }
      const repoInfo = { owner, repo };

      const headers: HeadersInit = {
        'Authorization': `Bearer ${state.githubToken}`
      };

      toast({ title: "Fetching Files...", description: "Getting repository file list." });
      
      const repoInfoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}`, { headers });
      if (!repoInfoResponse.ok) {
        if (repoInfoResponse.status === 404) {
          throw new Error("Repository not found. Check the URL and ensure your token has access to this repository.");
        }
        if (repoInfoResponse.status === 401) {
          throw new Error("Authentication failed. Make sure your GitHub Personal Access Token is correct and has 'repo' scope.");
        }
        if (repoInfoResponse.status === 403) {
          const errorData = await repoInfoResponse.json().catch(() => ({ message: "Rate limit likely exceeded or insufficient permissions."}));
          console.error("GitHub API Error:", errorData);
          throw new Error(`GitHub API access forbidden. ${errorData.message}`);
        }
        throw new Error(`Failed to fetch repository info: ${repoInfoResponse.statusText} (Status: ${repoInfoResponse.status})`);
      }
      const repoData = await repoInfoResponse.json();
      const defaultBranch = repoData.default_branch;

      const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${defaultBranch}?recursive=1`, { headers });
      if (!treeResponse.ok) {
        if (treeResponse.status === 404) {
          throw new Error("Could not find the repository's file tree. The default branch may not exist or is empty.");
        }
        if (treeResponse.status === 401) {
          throw new Error("Authentication failed. Make sure your GitHub Personal Access Token is correct and has 'repo' scope.");
        }
        if (treeResponse.status === 403) {
          const errorData = await treeResponse.json().catch(() => ({ message: "Rate limit likely exceeded or insufficient permissions."}));
          console.error("GitHub API Error:", errorData);
          throw new Error(`GitHub API access forbidden while fetching file tree. ${errorData.message}`);
        }
        throw new Error(`Failed to fetch repository file tree: ${treeResponse.statusText} (Status: ${treeResponse.status})`);
      }
      const treeData = await treeResponse.json();
      if(treeData.truncated) {
        toast({ title: "Warning", description: "Repository is too large, some files may not be scanned.", variant: "default" });
      }

      const ignoredPaths = ['node_modules/', 'dist/', 'build/', '.git/', 'vendor/', '.cache/', 'tmp/', 'temp/', '__pycache__/', '.pytest_cache/', '.vscode/', '.idea/', 'coverage/', 'test-results/', '.next/', '.nuxt/', '.expo/', '.history/', '.venv/', '.env/', '.mypy_cache/', '.terraform/', '.serverless/', '*.zip', '*.tar.gz', '*.rar', '*.7z', '*.png', '*.jpg', '*.jpeg', '*.gif', '*.svg', '*.ico', '*.pdf', '*.mp4'];

      const filesToScan = treeData.tree.filter((file: any) => 
        file.type === 'blob' &&
        !ignoredPaths.some(ignoredPath => file.path.startsWith(ignoredPath))
      ).map((file: any) => ({
        ...file,
        formattedSize: formatFileSize(file.size || 0)
      }));

      const totalSize = filesToScan.reduce((sum: number, file: any) => sum + (file.size || 0), 0);
      const totalFormattedSize = formatFileSize(totalSize);
      
      setState(prev => ({ ...prev, repoFiles: filesToScan, repoInfo }));

      if (filesToScan.length > 0) {
        toast({ title: "Files Loaded", description: `Found ${filesToScan.length} scannable files (${totalFormattedSize} total). Ready to scan.` });
      } else {
        toast({ title: "No Files Found", description: "No scannable files were found in this repository." });
      }

    } catch (error) {
      console.error("Fetch failed:", error);
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      setState(prev => ({ ...prev, repoFiles: null }));
    } finally {
      setState(prev => ({ ...prev, isLoading: false, activeAction: null }));
    }
  };

  const handleStartScan = async () => {
    if (!user) {
      toast({ title: "Error", description: "You must be logged in to perform scans.", variant: "destructive" });
      return;
    }

    if (!state.repoFiles || state.repoFiles.length === 0) {
      toast({ title: "Error", description: "No files to scan.", variant: "destructive" });
      return;
    }
    if (!state.repoInfo) {
      toast({ title: "Error", description: "Repository information is missing. Please fetch files first.", variant: "destructive" });
      return;
    }

    // Check if user has enough credits
    if (credits < 1) {
      toast({ 
        title: "Insufficient Credits", 
        description: "You need 1 credit to perform a scan. Please purchase more credits.", 
        variant: "destructive" 
      });
      return;
    }

    // Deduct credits first
    const creditsDeducted = await deductCredits(1);
    if (!creditsDeducted) {
      return; // Credits deduction failed, error already shown
    }

    setState(prev => ({
      ...prev,
      isLoading: true,
      activeAction: 'scan',
      isScanning: true,
      results: null,
    }));
    
    try {
      const { owner, repo } = state.repoInfo;

      // Record the scan in the database
      const { data: scanData, error: scanError } = await supabase
        .from('scans')
        .insert({
          user_id: user.id,
          repository_url: state.repoUrl,
          status: 'running',
          credits_used: 1
        })
        .select()
        .single();

      if (scanError) {
        console.error("Error recording scan:", scanError);
      }

      const headers: HeadersInit = {};
      if (state.githubToken) {
        headers['Authorization'] = `Bearer ${state.githubToken}`;
      }

      let vulnerabilityIdCounter = 1;
      let allVulnerabilities: Vulnerability[] = [];

      for (const [index, file] of state.repoFiles.entries()) {
        toast({ title: "Scanning", description: `Analyzing ${file.path} (${index + 1}/${state.repoFiles.length})` });
        
        await sleep(200);

        const fileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${file.path}`;
        const githubFileResponse = await fetch(fileUrl, { headers });

        if (!githubFileResponse.ok) {
          if (githubFileResponse.status === 401) {
            throw new Error("Authentication failed while fetching a file. Make sure your GitHub token is correct and has 'repo' scope. Scan aborted.");
          }
          console.warn(`Could not fetch file: ${file.path}. Status: ${githubFileResponse.statusText}`);
          continue;
        }

        try {
          const fileData = await githubFileResponse.json();
          
          if (fileData.size > 100000) { 
            console.warn(`Skipping large file: ${file.path}`);
            continue;
          }

          if (!fileData.content) {
            console.warn(`Skipping empty file: ${file.path}`);
            continue;
          }

          const fileContent = atob(fileData.content);

          const { data, error } = await supabase.functions.invoke('scan-vulnerability', {
            body: {
              fileContent: fileContent,
              filePath: file.path
            }
          });

          if (error) {
            console.error(`Error scanning file ${file.path}:`, error);
            toast({ title: "Scan Error", description: `Could not scan ${file.path}: ${error.message}`, variant: "destructive" });
            continue;
          }

          const vulnerabilitiesInFile = data.vulnerabilities || [];

          if (vulnerabilitiesInFile.length > 0) {
            const newVulnerabilities = vulnerabilitiesInFile.map((v: any) => ({
              ...v,
              id: vulnerabilityIdCounter++,
              file: file.path
            }));
            allVulnerabilities = [...allVulnerabilities, ...newVulnerabilities];
          }
        } catch (fileError) {
          console.error(`Error processing file ${file.path}:`, fileError);
          toast({ title: "File Processing Error", description: `An error occurred while scanning ${file.path}.`, variant: "destructive" });
        }
      }

      // Update scan status in the database
      if (scanData) {
        await supabase
          .from('scans')
          .update({
            status: 'completed',
            completed_at: new Date().toISOString()
          })
          .eq('id', scanData.id);
      }

      setState(prev => ({ ...prev, results: allVulnerabilities }));

      if (allVulnerabilities.length > 0) {
        toast({ title: "Scan Complete", description: `Found ${allVulnerabilities.length} potential vulnerabilities across ${state.repoFiles.length} files. 1 credit used.` });
      } else {
        toast({ title: "Scan Complete", description: `Scanned ${state.repoFiles.length} files. No vulnerabilities found. 1 credit used.` });
      }
    } catch (error) {
      console.error("Scan failed:", error);
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      
      // Update scan status to failed if we have a scan record
      try {
        await supabase
          .from('scans')
          .update({ status: 'failed' })
          .eq('user_id', user.id)
          .eq('repository_url', state.repoUrl)
          .eq('status', 'running');
      } catch (updateError) {
        console.error("Error updating scan status:", updateError);
      }
    } finally {
      setState(prev => ({
        ...prev,
        isLoading: false,
        activeAction: null,
        isScanning: false,
      }));
    }
  };

  const handleViewCode = async (vulnerability: Vulnerability) => {
    if (state.fileContents[vulnerability.file] || state.loadingFileContentForVulnId === vulnerability.id) {
      return;
    }
    if (!state.repoInfo) {
      toast({ title: "Error", description: "Repository information is missing.", variant: "destructive" });
      return;
    }

    setState(prev => ({ ...prev, loadingFileContentForVulnId: vulnerability.id }));
    try {
      const { owner, repo } = state.repoInfo;
      const headers: HeadersInit = {};
      if (state.githubToken) {
        headers['Authorization'] = `Bearer ${state.githubToken}`;
      }
      
      const fileUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${vulnerability.file}`;
      const response = await fetch(fileUrl, { headers });

      if (!response.ok) {
        throw new Error(`Failed to fetch file content for ${vulnerability.file}. Status: ${response.status}`);
      }

      const fileData = await response.json();
      if (!fileData.content) {
        setState(prev => ({ 
          ...prev, 
          fileContents: { ...prev.fileContents, [vulnerability.file]: "// File content is not available or file is empty." }
        }));
      } else {
        const content = atob(fileData.content);
        setState(prev => ({ 
          ...prev, 
          fileContents: { ...prev.fileContents, [vulnerability.file]: content }
        }));
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      setState(prev => ({ 
        ...prev, 
        fileContents: { ...prev.fileContents, [vulnerability.file]: `// Error: ${errorMessage}` }
      }));
    } finally {
      setState(prev => ({ ...prev, loadingFileContentForVulnId: null }));
    }
  };

  const setRepoUrl = (url: string) => {
    setState(prev => ({ ...prev, repoUrl: url }));
  };

  const setGithubToken = (token: string) => {
    setState(prev => ({ ...prev, githubToken: token }));
  };

  return {
    state,
    handleFetchFiles,
    handleStartScan,
    handleViewCode,
    setRepoUrl,
    setGithubToken,
  };
};
