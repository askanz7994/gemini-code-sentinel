
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.50.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { fileContent, filePath } = await req.json();

    if (!fileContent || !filePath) {
      return new Response(
        JSON.stringify({ error: 'Missing required fields' }), 
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    const geminiApiKey = Deno.env.get('GEMINI_API_KEY');
    if (!geminiApiKey) {
      return new Response(
        JSON.stringify({ error: 'Gemini API key not configured' }), 
        { 
          status: 500, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    const prompt = `
      Analyze the following code from the file '${filePath}' for security vulnerabilities.
      For each vulnerability, provide a concise description, a suggestion on how to fix it, explain how an attacker could exploit it to crash or compromise the app, provide penetration testing guidance, and show the complete corrected file.
      The severity MUST be one of: 'Critical', 'High', 'Medium', 'Low'.
      Respond with ONLY a valid JSON array of objects. Each object in the array must have the following schema: { "id": number, "file": string, "line": number, "severity": "Critical" | "High" | "Medium" | "Low", "description": string, "remediation": string, "exploit": string, "pentest": string, "patchedCode": string }.
      The 'remediation' attribute should contain a clear, actionable suggestion on how to patch the vulnerability.
      The 'exploit' attribute should explain in detail how a hacker could exploit this vulnerability to crash the app, cause denial of service, or compromise the system. Be specific about the attack vector and potential impact.
      The 'pentest' attribute should provide step-by-step penetration testing instructions for security professionals to verify this vulnerability, including specific tools, commands, payloads, or test cases that can be used to reproduce the issue.
      The 'patchedCode' attribute should contain the COMPLETE corrected version of the entire file with all vulnerabilities fixed, not just a code snippet. Include the full file content with all necessary imports, functions, and code structure intact.
      The 'file' attribute MUST be exactly '${filePath}'.
      The 'line' number should be the best guess for the line where the vulnerability is found. The 'id' can be a placeholder, it will be reassigned.
      If there are NO vulnerabilities in this file, you MUST return an empty array [].
      Do not include any text, notes, or explanations before or after the JSON array.

      Here is the code from '${filePath}':
      \`\`\`
      ${fileContent}
      \`\`\`
    `;

    const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
    const geminiResponse = await fetch(geminiApiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
      }),
    });

    if (!geminiResponse.ok) {
      const errorData = await geminiResponse.json().catch(() => null);
      const errorMessage = errorData?.error?.message || `Analysis failed for ${filePath} with status ${geminiResponse.status}.`;
      console.error(`Gemini API Error for ${filePath}:`, errorData || geminiResponse.statusText);
      return new Response(
        JSON.stringify({ error: errorMessage }), 
        { 
          status: geminiResponse.status, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    const geminiData = await geminiResponse.json();
    if (!geminiData.candidates || geminiData.candidates.length === 0 || !geminiData.candidates[0].content?.parts) {
      console.warn(`The AI returned an empty or invalid response for ${filePath}.`, geminiData);
      return new Response(
        JSON.stringify({ vulnerabilities: [] }), 
        { 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    const responseText = geminiData.candidates[0].content.parts[0].text;
    const cleanedResponse = responseText.replace(/```json/g, '').replace(/```/g, '').trim();

    let vulnerabilities = [];
    try {
      if (cleanedResponse) {
        vulnerabilities = JSON.parse(cleanedResponse);
      }
    } catch (e) {
      console.error(`Failed to parse AI response for ${filePath}:`, cleanedResponse);
      return new Response(
        JSON.stringify({ error: `Could not parse analysis for ${filePath}.` }), 
        { 
          status: 500, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    return new Response(
      JSON.stringify({ vulnerabilities }), 
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error in scan-vulnerability function:', error);
    return new Response(
      JSON.stringify({ error: error.message }), 
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
